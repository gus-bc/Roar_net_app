import logging
import math
from random import random
from time import perf_counter

from ..api.Operations import Problem, Solution, local_neighbourhood, moves, copy_solution, objective_value, random_move, \
    objective_value_increment, apply, is_feasible
from ..api.custom_logger import *


def simulated_annealing(problem: Problem, current_solution: Solution, initprob, sizefactor, cutoff, tempfactor,
                        freeze_lim, minpercent, logger: MetricLogger = None):
    """
    Performs Simulated Annealing on the given problem. The implementation is made from the pseudocode from
    Johnson et. al.

    :param problem: The problem instance.
    :param current_solution: Initial complete solution.
    :param initprob: Initial probability for accepting uphill moves.
    :param sizefactor: Factor to determine number of trials per temperature.
    :param cutoff: Factor to determine when to stop trials at a temperature.
    :param tempfactor: Factor to reduce temperature.
    :param freeze_lim: Limit for freezecount before terminating.
    :param minpercent: Minimum percentage of accepted changes to avoid incrementing freezecount.
    :param logger: Optional metric logger.
    :return: The best found solution.
    """

    # Calculate the actual temperature factor as specified in the paper
    tempfactor = round(0.95 ** (1 / tempfactor), 4)

    # Step 1: READ_INSTANCE (already done, problem is passed in)
    logging.info("Starting Simulated Annealing")
    start_time = perf_counter()

    neighborhood = local_neighbourhood(problem)

    neighborhood_size = len(list(moves(neighborhood, current_solution)))

    # Step 2: INITIAL_SOLUTION (current_solution is already passed in)
    current_solution = copy_solution(current_solution)
    current_cost = objective_value(current_solution)

    best_solution = copy_solution(current_solution)
    best_cost = current_cost

    # Step 3: Get initial temperature
    delta_samples = []
    sample_solution = copy_solution(current_solution)
    for _ in range(min(10, neighborhood_size)):
        move = random_move(neighborhood, sample_solution)
        if move:
            delta = objective_value_increment(move, sample_solution)
            if delta is not None and delta > 0:
                delta_samples.append(delta)

    # Set initial temperature
    if delta_samples:
        avg_delta = sum(delta_samples) / len(delta_samples)
        temp = -avg_delta / math.log(initprob)
    else:
        temp = 100.0

    # Step 4: Initialize freezecount
    freezecount = 0

    max_trails = sizefactor * neighborhood_size
    max_changes = cutoff * neighborhood_size
    logging.info(
        f"InitTemp: {temp}, max_trails: {max_trails}, max_changes: {max_changes} InitProb: {initprob}, SizeFactor: {sizefactor}, Cutoff: {cutoff}, "
        f"TempFactor: {tempfactor}, FreezeLimit: {freeze_lim}, MinAcceptedPercent: {minpercent}"
    )
    # Step 5: Main loop
    try:
        while freezecount < freeze_lim:
            changes = 0
            trials = 0
            improved = False

            while trials < max_trails and changes < max_changes:
                trials += 1

                move = random_move(neighborhood, current_solution)
                if not move:
                    continue

                delta = objective_value_increment(move, current_solution)
                if delta is None:
                    continue

                # Step 5.1.4: Handle downhill move
                if delta <= 0:
                    changes += 1
                    current_solution = apply(move, current_solution)
                    current_cost += delta

                    if is_feasible(current_solution) and current_cost < best_cost:
                        improved = True
                        best_solution = copy_solution(current_solution)
                        best_cost = current_cost
                        # Logging
                        cur_colours_used = current_solution.get_num_colours()
                        best_colours_used = best_solution.get_num_colours()
                        _time = perf_counter() - start_time
                        if logger:
                            logger.log_algo_metric(trials,
                                                   current_cost,
                                                   best_cost,
                                                   _time,
                                                   cur_colours_used,
                                                   best_colours_used)

                # Step 5.1.5: Handle uphill move
                else:
                    acceptance_prob = math.exp(-delta / temp)
                    if random() <= acceptance_prob:
                        changes += 1
                        current_solution = apply(move, current_solution)
                        current_cost += delta


            # Step 5.2: Cool down and check freezing
            temp *= tempfactor

            if improved:
                freezecount = 0

            if changes / trials < minpercent:
                freezecount += 1

            # Logging
            cur_colours_used = current_solution.get_num_colours()
            best_colours_used = best_solution.get_num_colours()
            _time = perf_counter() - start_time
            if logger:
                logger.log_algo_metric(trials,
                                       current_cost,
                                       best_cost,
                                       _time,
                                       cur_colours_used,
                                       best_colours_used)
            logging.info(
                f"Improved: {improved}, Freezecount: {freezecount}, temp: {temp}, Changes: {changes}, Trial: {trials}, Time: {_time:.2f}s, Current Cost: {current_cost}, Best Cost: {best_cost}, "
                f"Current Colours: {cur_colours_used}, Best Colours: {best_colours_used}"
            )


    except KeyboardInterrupt:
        logging.warning("Manual stop detected! Returning best solution found so far.")
        return best_solution
    logging.info(f"Finished Simulated Annealing. Best objective: {best_cost}")
    return best_solution