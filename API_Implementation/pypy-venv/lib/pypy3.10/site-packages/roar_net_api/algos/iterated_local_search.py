import logging
import math
from time import perf_counter

from ..api.Operations import *


def iterated_local_search(problem: Problem, solution: Solution, max_iterations: int, perturbation_strength: int):
    """
    Performs Iterated Local Search (ILS) on the given problem.

    :param problem: The problem instance.
    :param solution: Initial solution.
    :param max_iterations: Maximum number of iterations.
    :param perturbation_strength: Number of random destruction moves to apply in perturbation.
    :return: The best found solution.
    """
    logging.info("Starting ILS")
    logging.info(
        f"Max Iterations: {max_iterations} - Perturbation Strength: {perturbation_strength}")
    start_time = perf_counter()

    current_solution = solution
    best_solution = copy_solution(current_solution)
    try:
        for iteration in range(max_iterations):
            current_solution = local_search(problem, current_solution)

            if objective_value(current_solution) < objective_value(best_solution):
                best_solution = copy_solution(current_solution)
            logging.info(f"ILS - Iteration: {iteration} - Cost: {current_solution.cost}\nsolution: {current_solution}")
            current_solution = perturbation(problem, best_solution, perturbation_strength)

    except KeyboardInterrupt:
        logging.warning("Manual stop detected! Returning best solution found so far.")

    end_time = perf_counter()
    logging.info(f"ILS Search completed in {end_time - start_time:.2f} seconds")

    return best_solution


def local_search(problem: Problem, solution: Solution):
    improvement = True
    while improvement:
        improvement = False
        best_move = None
        best_improvement = 0

        for move in moves(local_neighbourhood(problem), solution):
            delta = objective_value_increment(move, solution)
            if delta is not None and delta < best_improvement:
                best_improvement = delta
                best_move = move

        if best_move:
            solution = apply(best_move, solution)

            improvement = True
    return solution


def perturbation(problem: Problem, solution: Solution, strength: int):
    for _ in range(strength):
        move = random_move(destruction_neighbourhood(problem), solution)
        if move:
            solution = apply(move, solution)
    while True:
        construction_move = random_move(construction_neighbourhood(problem), solution)
        if construction_move:
            solution = apply(construction_move, solution)
        else:
            break
    return solution
