
import multiprocessing


from ..api.Operations import *


from time import perf_counter
import logging


def evaluate_move(args):
    """ Helper function to evaluate a move in parallel. Necessary as imap_unordered can't take a lambd function."""
    move, solution = args
    #print(f"Evaluating move: {move}")
    return move, objective_value_increment(move, solution)

def multi_process_best_improvement(problem: Problem, solution: Solution, budget: float) -> Solution:
    start = perf_counter()
    cant_improve = False
    manager = multiprocessing.Manager()
    lock = manager.Lock()

    round = 0

    while perf_counter() - start < budget and not cant_improve:
        round_start = perf_counter()
        best_incr = 0
        best_move = None
        neighbourhood: Neighbourhood = local_neighbourhood(problem)
        cant_improve = True

        moves_list = list(moves(neighbourhood, solution))
        if not moves_list:
            break

        with multiprocessing.Pool(processes=multiprocessing.cpu_count()) as pool:
            for move, delta in pool.imap_unordered(evaluate_move, [(move, solution) for move in moves_list]):
                with lock:
                    if delta < best_incr:
                        logging.debug(f"delta: {delta} - best_incr: {best_incr} - move: {move} - round: {round}")
                        best_incr = delta
                        best_move = move
                        cant_improve = False

                if perf_counter() - start >= budget:
                    logging.info(f"Budget: {budget} hit")
                    pool.terminate()

                    return apply(best_move, solution)

        round_time = perf_counter() - round_start  # Calculate round duration
        #logging.info(f"Round {round} completed in {round_time:.4f} seconds")  # Log time

        if best_move is not None:
            #logging.info(f"Improvement found - Move: {best_move} - Solution cost: {objective_value(solution)} - best_incr: {best_incr} - round: {round}")
            apply(best_move, solution)
            round += 1
        else:
            break

    logging.info(f"Best found solution - Multi process  - cost: {objective_value(solution)} - Total time used: {perf_counter() - start}")
    return solution