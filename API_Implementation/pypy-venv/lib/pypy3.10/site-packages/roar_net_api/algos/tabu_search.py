import inspect
import logging
import math
from time import perf_counter
from ..api.custom_logger import get_metric_logger
from ..api.Operations import *
from typing import Dict, Optional


def tabu_search(
        problem: Problem,
        current_solution: Solution,
        tabu_tenure: int,
        max_iterations: int,
        aspiration_criteria: float,
        clean_iter: int,
        idle_iterations: int,
        rep: int = 0
) -> Optional[Solution]:
    """
    Perform Tabu Search to find an optimized solution.

    :param problem: The problem to be solved
    :param current_solution: The instance of the solution improve
    :param tabu_tenure: Number of iterations a move remains tabu
    :param max_iterations: Maximum number of iterations
    :param aspiration_criteria: Threshold to accept a move even if tabu
    :param clean_iter: Cleans tabu list every clean_iter'th iteration
    :param idle_iterations: Stops after n'th iteration without improvement
    :param rep: Number of neighbors sampled per iteration, if 0 all neighbors are sampled

    :return: The best solution found
    """
    best_solution = copy_solution(current_solution)
    best_objective = objective_value(best_solution)

    try:
        logger = get_metric_logger()
        logging.info("Starting Tabu Search")
        logging.info(f"Max Iterations: {max_iterations}, Rep: {rep}, Tabu Tenure: {tabu_tenure}, Aspiration: {aspiration_criteria}")

        tabu_list: Dict[Move, int] = {}
        iteration = 0
        last_improvement = 0
        start_time = perf_counter()

        while iteration < max_iterations and last_improvement < idle_iterations:
            if iteration == 100:
                pass

            neighborhood = local_neighbourhood(problem)
            best_move = None
            best_move_value = math.inf

            move = random_moves_without_replacement(neighborhood, current_solution)
            moves_checked = 0
            while (moves_checked < rep) if rep != 0 else move is not None:
                move_value = objective_value_increment(move, current_solution)
                moves_checked += 1
                # Allow move if it's not tabu, its tabu tenure expired, or it meets aspiration criteria
                if (move not in tabu_list or tabu_list[move] < iteration) or move_value <= aspiration_criteria:

                    if move_value <= aspiration_criteria:
                        logging.info(f"Aspiration criterion met: {move}")

                    if move_value < best_move_value:
                        best_move = move
                        best_move_value = move_value

                        # Early exit if this move improves the overall best known objective
                        if best_move_value < best_objective:
                            break

                move = random_moves_without_replacement(neighborhood, current_solution)


            if best_move is None:
                break

            current_solution = apply(best_move, current_solution)
            current_objective = objective_value(current_solution)

            last_improvement += 1
            if current_objective < best_objective:
                last_improvement = 0
                best_solution = copy_solution(current_solution)
                best_objective = current_objective

            iteration += 1

            # Update tabu list
            tabu_list[best_move.invert()] = iteration + tabu_tenure
            tabu_list[best_move] = iteration + tabu_tenure

            # Clean tabu list periodically
            if iteration % clean_iter == 0:
                tabu_list = {m: exp for m, exp in tabu_list.items() if exp > iteration}

            # Log to CSV
            time = perf_counter()-start_time
            logger.log_algo_metric(iteration, current_objective, best_objective, time)
            # Log to console
            logging.info(f"iteration: {iteration}, moves checked: {moves_checked}, current_objective: {current_objective}, current #Colours: {current_solution.get_num_colours()}, best_objective: {best_objective}, best #Colours: {best_solution.get_num_colours()}, time: {time}")
            logging.info(f"Best_move: {best_move}")

        return best_solution

    except KeyboardInterrupt:
        logging.warning("Manual stop detected! Returning best solution found so far.")
        return best_solution
    except Exception as e:
        logging.error(e)

