import logging
import time

import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
from pathlib import Path

ALGO_METRIC = 25
logging.addLevelName(ALGO_METRIC, "ALGO_METRIC")

_singleton_logger = None
_plot = False
_last_plot_time = 0

# To store the metric data for graphing purposes
iteration_data = []
cur_evaluation_data = []
best_evaluation_data = []
time_used_data = []


class MetricLogger(logging.Logger):
    def log_algo_metric(self, iteration, cur_evaluation, best_evaluation, time_used):
        """
        Logs the algorithm's performance metrics at each iteration.

        Parameters:
        iteration (int): The current iteration number of the algorithm.
        cur_evaluation (float): The evaluation metric value of the algorithm at the current iteration.
        best_evaluation (float): The best evaluation metric value found so far by the algorithm.
        time_used (float): The amount of time (in seconds) used during the current iteration.

        Returns:
        None: This method does not return any value; it is used to log or print the metrics.
        """
        if self.isEnabledFor(ALGO_METRIC):
            # Store the metric data for graphing

            if type(iteration) == int:
                iteration_data.append(iteration)
                cur_evaluation_data.append(cur_evaluation)
                best_evaluation_data.append(best_evaluation)
                time_used_data.append(time_used)

            # Log the message
            message = f"{iteration}, {cur_evaluation}, {best_evaluation}, {time_used}"
            self._log(ALGO_METRIC, message, ())

            # Update the graph with new data
            if _plot:
                update_graph()

def update_graph():
    global _last_plot_time
    current_time = time.time()

    # Only update the plot if at least 1 second has passed
    if current_time - _last_plot_time >= 0.5:
        _last_plot_time = current_time
        plt.clf()  # Clear the figure before plotting again

        # Create a single subplot for both curves
        plt.plot(iteration_data, best_evaluation_data, label='Best Evaluation', color='blue')
        plt.plot(iteration_data, cur_evaluation_data, label='Current Evaluation', color='orange')

        # Add titles and labels
        plt.title('Evaluation vs Iteration')
        plt.xlabel('Iteration')
        plt.ylabel('Evaluation')

        # Add a legend to differentiate the lines
        plt.legend()

        if len(best_evaluation_data) > 1:
            max_iteration = max(iteration_data) if iteration_data else 0
            min_y = min(min(best_evaluation_data), min(cur_evaluation_data)) - 10
            max_y = max(max(best_evaluation_data), max(cur_evaluation_data)) + 10

            plt.xlim(0, max_iteration + 10)  # Add some padding to the max iteration for clarity
            plt.ylim(min_y, max_y)  # Add padding to y-axis

            # Use MaxNLocator to limit the number of ticks
            plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True, prune='lower', nbins=20))  # 20 ticks for x-axis
            plt.gca().yaxis.set_major_locator(MaxNLocator(nbins=15))  # 15 ticks for y-axis

        # Adjust layout and show the plot
        plt.draw()
        plt.pause(0.05)  # Pause to allow the plot to update


def add_metric_logger(file_name: str, plot: bool = False) -> Path:
    """Creates singleton logger if it doesn't exist yet."""
    if not file_name:
        raise Exception("No provided log filename.")

    global _plot
    _plot = plot

    global _singleton_logger
    _singleton_logger = MetricLogger("singleton_logger", ALGO_METRIC)

    file_parts = file_name.split(".")
    file_parts[-2] = file_parts[-2] + "_1"
    file_name = ".".join(file_parts)
    path_without_file = "/".join(file_name.split("/")[0:-1])
    while file_name.split("/")[-1] in [file.name for file in Path(path_without_file).iterdir()]:
        file_parts = file_name.split("_")
        base_name = "_".join(file_parts[:-1])
        num_part = int(file_parts[-1].split(".")[0])
        file_name = base_name + "_" + str(num_part + 1) + "." + ".".join(file_parts[-1].split(".")[1:])

    handler = logging.FileHandler(file_name, mode="w")
    handler.setFormatter(logging.Formatter("%(message)s"))

    _singleton_logger.addHandler(handler)
    _singleton_logger.setLevel(ALGO_METRIC)

    _singleton_logger.log_algo_metric("Iteration", "Evaluation", "Best_evaluation", "Time Used")

    # Initialize the plot
    plt.ion()  # Turn on interactive mode for real-time plotting

    return Path(file_name)


def get_metric_logger():
    """Retrieve the singleton logger."""
    global _singleton_logger

    if _singleton_logger is None:
        raise Exception("Metric logger hasn't been added.")

    return _singleton_logger