import subprocess
from pathlib import Path
from random import random

import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
from matplotlib.ticker import MaxNLocator
from itertools import combinations
from typing import Dict, TextIO, Optional
from math import ceil, log2
import random

from .Types import *

def adjacency_matrix(v: int, edge_list: EdgeList) -> np.ndarray:
    """Creates an adjacency matrix using NumPy."""
    matrix = np.zeros((v, v), dtype=int)
    for edge in edge_list:
        matrix[edge[0], edge[1]] = 1
        matrix[edge[1], edge[0]] = 1
    return matrix


def adjacency_list(v: int, edge_list: EdgeList) -> Dict[int, np.ndarray]:
    """Creates an adjacency list using NumPy arrays."""
    adj_list = {i: np.array([], dtype=int) for i in range(v)}
    for vertex1, vertex2 in edge_list:
        adj_list[vertex1] = np.append(adj_list[vertex1], vertex2)
        adj_list[vertex2] = np.append(adj_list[vertex2], vertex1)
    return adj_list


def calc_vertex_not_assigned(vertex_colours: np.ndarray) -> int:
    """Calculates the number of unassigned vertices."""
    return np.count_nonzero(vertex_colours == 0)


def print_matrix(matrix: np.ndarray):
    """Prints an adjacency matrix in a formatted way."""
    if matrix.size == 0:
        print("\nEmpty matrix:")
        return

    col_widths = [max(len(str(cell)) for cell in col) for col in matrix.T]
    print("\nAdjacency matrix:")
    for row in matrix:
        print(" | ".join(f"{str(cell):<{col_widths[i]}}" for i, cell in enumerate(row)))


def print_adj_list(adj_list: Dict[int, np.ndarray]):
    """Prints an adjacency list in a formatted way."""
    print("Adjacency list")
    for node, neighbors in sorted(adj_list.items()):
        neighbors_str = ", ".join(map(str, sorted(neighbors)))
        print(f"{node} -> {neighbors_str}")


def plot_graph_from_adj_matrix(solution):
    """Constructs a graph from an adjacency matrix and plots it."""
    G = nx.from_numpy_array(np.array(solution.problem.adjacency_matrix))
    node_colors = np.array([n for n in solution.vertex_colours.values()])

    pos = nx.spring_layout(G)
    edge_colors = ["red" if node_colors[u] == node_colors[v] else "gray" for u, v in G.edges()]

    plt.figure(figsize=(8, 6))
    nx.draw(G, pos, with_labels=True, node_color=node_colors, node_size=700,
            font_size=14, font_weight='bold', edge_color=edge_colors, width=2, edge_cmap=plt.cm.Reds)

    plt.title("Graph with Colored Edges")
    plt.show()


def unique_combinations(x: int) -> np.ndarray:
    """Generates unique combinations using NumPy."""
    return np.array(list(combinations(range(1, x + 1), 2)))


def isclose(a: float, b: float, rel_tol=1e-6, abs_tol=1e-9) -> bool:
    """Compares floating-point values for closeness using NumPy."""
    return np.isclose(a, b, rtol=rel_tol, atol=abs_tol)


def count_edges(nodes: np.ndarray, adjacency_list: Dict[int, np.ndarray]) -> int:
    """Counts the number of edges in a given node set using NumPy."""
    edge_count = sum(np.isin(adjacency_list[node], nodes).sum() for node in nodes)
    return edge_count // 2

def non_repeating_lcg(n: int, seed: Optional[int] = None) -> Iterable[int]:
    if seed is not None:
        random.seed(seed)
    "Pseudorandom sampling without replacement in O(1) space"
    if n > 0:
        a = 5 # always 5
        m = 1 << ceil(log2(n))
        if m > 1:
            c = random.randrange(1, m, 2)
            x = random.randrange(m)
            for _ in range(m):
                if x < n: yield x
                x = (a * x + c) % m
        else:
            yield 0

def sample(n: int, seed: Optional[int] = None) -> Iterable[int]:
    for v in non_repeating_lcg(n, seed):
        yield v

def sample2(n: int, m: int, seed: Optional[int] = None) -> Iterable[Tuple[int, int]]:
    for v in non_repeating_lcg(n*m, seed):
        i = v // m
        j = v % m + 1
        yield i, j


def plot_evaluation(csv_file: str | Path):
    csv_file = Path(csv_file)

    df = pd.read_csv(csv_file)
    iteration_data = df.iloc[:, 0]
    cur_evaluation_data = df.iloc[:, 1]
    best_evaluation_data = df.iloc[:, 2]

    plt.figure(figsize=(10, 6))
    plt.plot(iteration_data, best_evaluation_data, label='Best Evaluation', color='blue')
    plt.plot(iteration_data, cur_evaluation_data, label='Current Evaluation', color='orange')

    plt.title('Evaluation vs Iteration')
    plt.xlabel('Iteration')
    plt.ylabel('Evaluation')

    plt.legend()

    if len(best_evaluation_data) > 1:
        max_iteration = max(iteration_data) if not iteration_data.empty else 0
        min_y = min(min(best_evaluation_data), min(cur_evaluation_data)) - 10
        max_y = max(max(best_evaluation_data), max(cur_evaluation_data)) + 10

        # Padding
        plt.xlim(0, max_iteration + 10)
        plt.ylim(min_y, max_y)

        # Use MaxNLocator to limit the number of ticks
        plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True, prune='lower', nbins=20))  # 20 ticks for x-axis
        plt.gca().yaxis.set_major_locator(MaxNLocator(nbins=15))  # 15 ticks for y-axis

    plt.show(block=True)


import pandas as pd
import altair as alt
from pathlib import Path

def plot_evaluation_marimo(csv_file: str | Path):
    csv_file = Path(csv_file)
    df = pd.read_csv(csv_file)

    # Assuming the columns are unnamed and are the first three
    df.columns = ['Iteration', 'Current Evaluation', 'Best Evaluation' 'Time Used']

    # Melt the DataFrame to long-form for Altair
    df_melted = df.melt(id_vars='Iteration',
                        value_vars=['Current Evaluation', 'Best Evaluation', 'Time Used'],
                        var_name='Type', value_name='Evaluation')

    chart = alt.Chart(df_melted).mark_line().encode(
        x=alt.X('Iteration:Q', title='Iteration'),
        y=alt.Y('Evaluation:Q', title='Evaluation'),
        color=alt.Color('Type:N', title='Evaluation Type', scale=alt.Scale(scheme='category10')),
        tooltip=['Iteration', 'Type', 'Evaluation']
    ).properties(
        title='Evaluation vs Iteration',
        width=700,
        height=400
    ).interactive()  # allows zoom/pan

    return chart

def run_solution_checker(instance_file: str | Path, solution_file: str | Path, problem_type: int = 1):
    verifier_path = Path("verifier_src/coloring-verifier")
    instance_file = Path(instance_file)
    solution_file = Path(solution_file)
    try:
        result = subprocess.run([
            verifier_path, "-i", str(instance_file), "-s", str(solution_file), "-p", str(problem_type)
        ], capture_output=True, text=True, check=True)
        return "Solution Checker Output:\n" + result.stdout
    except subprocess.CalledProcessError as e:
        return "Error running solution checker:\n" + e.stderr